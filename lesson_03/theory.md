## Некоторые нюансы

* У нас с базой данных соединение сейчас одно - ровно один объект `Connection`
* Все запросы у нас происходят в рамках одного этого объекта
* В единицу времени в рамках одного `Connection` может выполняться ТОЛЬКО ОДИН ЗАПРОС
* Если хотим больше - надо делать много `Connection` и заставить их работать параллельно (каждый в своем `thread`).
* Важно, если мы будем для каждого запроса создавать НОВЫЙ Connection, у нас будет утечка памяти, мы должны научиться переиспользовать те, которые у нас были.

### Ситуация 1

* Множество клиентов (например, 10), каждый из них делает 10 000 INSERT-запросов в базу в рамках одного `Connection` (см. `ExecutorService`)
* Каждый клиент - это отдельный `thread`, который делает 10 000 INSERT-ов в базу.
* Получаем примерно 15 секунд на выполнение такой задачи, хотим ускорения.

![image](https://raw.githubusercontent.com/ait-tr/backend-level-up-1/main/back_end/lesson_03/img/1.png)

### Ситуация 2

* Оставляем такое же множество клиентов, но при этом, мы создаем `ConnectionPool` на основе библиотеки `HikariCP`
* Здесь мы используем не 1 объект `Connection`, а сразу 20, и сама библиотека распределяет КАЖДЫЙ ЗАПРОС на определенный `Connection`
* Если `Connection` занят, то запрос уходит в очередь и ждет освободившегося `Connection`
* Внутри `HikariCP` работает такой же `ThreadPool`, просто в каждом `thread` этого пула находится свой `connection`
* Следовательно, когда приходит новый запрос в `HikariCP`, то он кладет этот запрос в очередь запросов, а когда какой-либо из потоков освобождается:
  * Этот поток берет запрос из очереди и выполняет его с использованием своего собственного `Connection`
  * Если потоков свободных нет, то запрос ждет в очереди запросов
* Прирост производительности `ConnectionPool` в том, что каждый запрос выполняется в своем потоке и в своем `connection`

![image](https://raw.githubusercontent.com/ait-tr/backend-level-up-1/main/back_end/lesson_03/img/2.png)

### ExecutorService

* Это класс, который представляет собой реализацию паттерна `Thread Pool` (пул потоков)
* Внутри данного класса (в случае FixedThreadPool) мы одновременно запускаем 10 потоков, которое работают параллельно
* Они запускаются сразу при создании объекта
* Глобально `ExecutorService` позволяет выполнять огромное количество задач в "параллельном" (фоновом режиме) внутри нескольких потоков 

```
try (ExecutorService service = Executors.newFixedThreadPool(10)) {
    for (int j = 0; j < 10; j++) {
        service.submit( () -> {какая-то задача});
    }
    ...
}
```

* Это означает, что в очередь попадет 10 каких-то задач и каждый поток будет выполнять свою задачу
* Если количество потоков будет меньше, чем задач, то некоторые задачи будут простаивать, пока не освободиться нужный поток.
* Помешаем внутрь `try (...)` (`try-with-resources`, чтобы он автоматически закрыл потоки, когда задач не осталось.

![image](https://raw.githubusercontent.com/ait-tr/backend-level-up-1/main/back_end/lesson_03/img/3.png)

## Дополнительный интерфейс:

* `DataSource` - интерфейс (стандартный из `java.sql`) он описывает объект, который предоставляет подключения к базе.

```
Connection getConnection()
```

* В нашем случае, мы использовали реализацию этого интерфейса от `HikariCP`

## Web

![image](https://raw.githubusercontent.com/ait-tr/backend-level-up-1/main/back_end/lesson_03/img/4.png)